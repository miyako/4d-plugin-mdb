/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-mdb.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : mdb
 #	author : miyako
 #	2024/05/14
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-mdb.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- mdb
            
			case 1 :
                mdb_sql(params);
				break;
            case 2 :
                mdb_tables(params);
                break;
            case 3 :
                mdb_export(params);
                break;
            case 4 :
                mdb_schema(params);
                break;
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#define is_binary_type(x) (x==MDB_OLE || x==MDB_BINARY || x==MDB_REPID)
#define EXPORT_BIND_SIZE 200000

static void format_value(FILE *outfile, char *value, size_t length, int col_type) {

    if(is_binary_type(col_type)) {
        char *quote_char_binary_sqlite = (char *) g_strdup("'");
        fputs("X", outfile);
        mdb_print_col(outfile,
                      value,
                      1,
                      col_type,
                      (int)length,
                      quote_char_binary_sqlite,
                      NULL,
                      MDB_BINEXPORT_HEXADECIMAL);
        g_free (quote_char_binary_sqlite);
    }else {
        mdb_print_col(outfile, value, 1, col_type, (int)length, (char *)"'", NULL, MDB_BINEXPORT_HEXADECIMAL);
    }
}

static void mdb_export(PA_PluginParameters params) {
    
//    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef returnValue;
    returnValue = PA_CreateObject();
    ob_set_b(returnValue, L"success", false);
    
    C_TEXT Param1;
    Param1.fromParamAtIndex(pParams, 1);
    CUTF8String path;
    Param1.copyUTF8String(&path);
    
    C_TEXT Param2;
    Param2.fromParamAtIndex(pParams, 2);
    CUTF8String name;
    Param2.copyUTF8String(&name);
    
    C_TEXT Param3;
    Param3.fromParamAtIndex(pParams, 3);
    CUTF8String output;
    Param3.copyUTF8String(&output);
    
    if(path.length()) {
        MdbHandle *mdb = mdb_open ((char *)path.c_str(), MDB_NOFLAGS);
        if(mdb) {
            
            mdb_set_date_fmt(mdb, "%Y/%m/%d %H:%M:%S:00");
            mdb_set_shortdate_fmt(mdb, "%Y/%m/%d 00:00:00:00");
            mdb_set_bind_size(mdb, EXPORT_BIND_SIZE);
            
            MdbTableDef *table = mdb_read_table_by_name(mdb, (char *)name.c_str(), MDB_TABLE);
            if(table) {
                mdb_read_columns(table);
                mdb_rewind_table(table);
                char **bound_values = (char **)g_malloc(table->num_cols * sizeof(char *));
                int  *bound_lens = (int  *)g_malloc(table->num_cols * sizeof(int));
                unsigned int i;
                int batch_size = 1000;
                int counter = 0;
                std::string quoted_table_name = "[";
                quoted_table_name += (const char *)name.c_str();
                quoted_table_name += "]";
                char *value;
                size_t length;
                bool bound = true;
                for (i = 0; i < table->num_cols; i++) {
                    /* bind columns */
                    bound_values[i] = (char *)g_malloc0(EXPORT_BIND_SIZE);
                    int ret = mdb_bind_column(table, i + 1, bound_values[i], &bound_lens[i]);
                    if (ret == -1) {
                        bound = false;
                        break;
                    }
                }
                if(bound) {
                    FILE *fp = fopen((char *)output.c_str(), "wb");
                    if(fp) {
                        while (mdb_fetch_row(table)) {
                            if (counter % batch_size == 0) {
                                counter = 0;
                                fprintf(fp, "INSERT INTO %s ( ", quoted_table_name.c_str());
                                for (i = 0; i < table->num_cols; ++i) {
                                    if (i > 0) fputs(" , ", fp);
                                    MdbColumn *col = (MdbColumn *)g_ptr_array_index(table->columns, i);
                                    std::string quoted_field_name = "[";
                                    quoted_field_name += col->name;
                                    quoted_field_name += "]";
                                    fputs(quoted_field_name.c_str(), fp);
                                }
                                fputs(" )\nVALUES ", fp);
                            } else {
                                fputs(",\n       ", fp);
                            }
                            fputs("( ", fp);
                            for (i = 0; i < table->num_cols; ++i) {
                                if (i > 0)
                                    fputs(" , ", fp);
                                MdbColumn *col = (MdbColumn *)g_ptr_array_index(table->columns, i);
                                if (!bound_lens[i]) {
                                    fputs("NULL", fp);
                                } else {
                                    if (col->col_type == MDB_OLE) {
                                        value = (char *)mdb_ole_read_full(mdb, col, &length);
                                    } else {
                                        value = bound_values[i];
                                        length = bound_lens[i];
                                    }
                                    format_value(fp, value, length, col->col_type);
                                    if (col->col_type == MDB_OLE)
                                        free(value);
                                }
                            }
                            fputs(" )", fp);
                            if (counter % batch_size == batch_size - 1) {
                                fputs(";\n", fp);
                            }
                            counter++;
                        }
                        if (counter % batch_size != 0) {
                            fputs(";\n", fp);
                        }
                        fclose(fp);
                        ob_set_b(returnValue, L"success", true);
                    }else{
                        ob_set_s(returnValue, "errorMessage", "failed: fopen()");
                    }
                }else{
                    ob_set_s(returnValue, "errorMessage", "failed: mdb_bind_column()");
                }
                for (unsigned int i=0; i<table->num_cols; ++i) {
                    g_free(bound_values[i]);
                }
                g_free(bound_values);
                g_free(bound_lens);
                mdb_free_tabledef(table);
            }else{
                ob_set_s(returnValue, "errorMessage", "failed: mdb_read_table_by_name()");
            }
            mdb_close(mdb);
        }else{
            ob_set_s(returnValue, "errorMessage", "failed: mdb_open()");
        }
    }
    PA_ReturnObject(params, returnValue);
}

static void mdb_column_definition (MdbColumn *col, std::string& column_definition) {
    
    std::string quoted_field_name = " [";
    quoted_field_name += col->name;
    quoted_field_name += "] ";
        
    switch (col->col_type) {
        case MDB_BOOL:
            column_definition = "Boolean";
            break;
        case MDB_BYTE:
        case MDB_INT:
        case MDB_LONGINT:
        case MDB_COMPLEX:
            column_definition = "Int";
            break;
        case MDB_MONEY:
        case MDB_FLOAT:
        case MDB_DOUBLE:
        case MDB_NUMERIC:
            column_definition = "Real";
            break;
        case MDB_DATETIME:
            column_definition = "Timestamp";
            break;
        case MDB_BINARY:
        case MDB_OLE:
            column_definition = "Blob";
            break;
        case MDB_TEXT:
        case MDB_MEMO:
                if ((col->col_size == 0) || (col->col_size > 0xFF) || (col->col_size < 0)){
                    column_definition = "Text";
                }else{
                    column_definition = "Varchar (";
                    column_definition+= std::to_string(col->col_size);
                    column_definition+= ")";
                }
            break;
        case MDB_REPID:
            column_definition = "UUID";
            break;
    }
        
    /*
     UNIQUE is defined as index
     PRIMARY KEY is defined as constraint
     4D has no concept of allow zero length as the SQL engine level
     4D has no concept of default value at the DB engine level
     */
    
    const gchar *required = mdb_col_get_prop(col, "Required");
    if ((required && required[0]=='y')||(col->col_type == MDB_BOOL)) {
        column_definition += " NOT NULL";
    }
    
    column_definition = quoted_field_name + column_definition;

    MdbTableDef *table = col->table;
        
    for (unsigned int i = 0; i < table->num_idxs; ++i) {
        MdbIndex *idx = (MdbIndex *)g_ptr_array_index (table->indices, i);
        if (idx->index_type==2) {
            continue;
        }
        if (idx->index_type==1) {
            continue;
        }else if (idx->flags & MDB_IDX_UNIQUE){
            for (unsigned int j = 0; j<idx->num_keys; ++j) {
                MdbColumn *idxcol= (MdbColumn *)g_ptr_array_index(table->columns, idx->key_col_num[j]-1);
                if(idxcol == col) {
                    column_definition += " UNIQUE";
                    break;
                }
            }
        }
    }
    
    switch (col->col_type) {
        case MDB_BYTE:
        case MDB_INT:
        case MDB_LONGINT:
        case MDB_COMPLEX:
            if(col->is_long_auto) {
                column_definition += " AUTO_INCREMENT";
            }
            break;
        case MDB_REPID:
            if(col->is_uuid_auto) {
                column_definition += " AUTO_GENERATE";
            }
            break;
    }
}

static void mdb_schema(PA_PluginParameters params) {

    //    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef returnValue;
    returnValue = PA_CreateObject();
    ob_set_b(returnValue, L"success", false);
    
    C_TEXT Param1;
    Param1.fromParamAtIndex(pParams, 1);
    CUTF8String path;
    Param1.copyUTF8String(&path);
    
    C_TEXT Param2;
    Param2.fromParamAtIndex(pParams, 2);
    CUTF8String output;
    Param2.copyUTF8String(&output);

    if(path.length()) {
        MdbHandle *mdb = mdb_open ((char *)path.c_str(), MDB_NOFLAGS);
        if(mdb) {
            if(mdb_read_catalog (mdb, MDB_TABLE)) {
                                
                const char *charset = mdb_target_charset(mdb);
                ob_set_s(returnValue, "charset", charset);
                FILE *fp = fopen((char *)output.c_str(), "wb");
                if(fp) {
                    for (unsigned int i=0; i < mdb->num_catalog; ++i) {
                        MdbCatalogEntry *entry = (MdbCatalogEntry *)g_ptr_array_index (mdb->catalog, i);
                        if (entry->object_type == MDB_TABLE) {
                            if (mdb_is_user_table(entry)) {
                                std::string name = entry->object_name;
                                std::string quoted_table_name = "[";
                                quoted_table_name += (const char *)name.c_str();
                                quoted_table_name += "]";
                                fprintf(fp, "CREATE TABLE IF NOT EXISTS %s (\n", quoted_table_name.c_str());
                                MdbTableDef *table = mdb_read_table (entry);
                                mdb_read_columns(table);
                                mdb_read_indices(table);
                                for (unsigned int j = 0; j < table->num_cols; ++j) {
                                    MdbColumn *col = (MdbColumn *)g_ptr_array_index (table->columns, j);
                                    std::string column_definition;
                                    mdb_column_definition(col, column_definition);
                                    fputs(column_definition.c_str(), fp);
                                    if (j < table->num_cols - 1) {
                                        fputs(",\n", fp);
                                    }
                                    else {
                                        for (unsigned int j = 0; j < table->num_idxs; ++j) {
                                            MdbIndex *idx = (MdbIndex *)g_ptr_array_index (table->indices, j);
                                            if (idx->index_type==2) {
                                                continue;
                                            }
                                            if (idx->index_type==1) {
                                                fputs(",\n PRIMARY KEY ( ", fp);
                                                for (unsigned int k = 0; k < idx->num_keys; ++k) {
                                                    if(k) fputs(" , ", fp);
                                                    MdbColumn *col= (MdbColumn *)g_ptr_array_index(table->columns, idx->key_col_num[k]-1);
                                                    std::string quoted_field_name = "[";
                                                    quoted_field_name += col->name;
                                                    quoted_field_name += "]";
                                                    fputs(quoted_field_name.c_str(), fp);
                                                }
                                                fputs(" )", fp);
                                                break;
                                            }
                                        }
                                    }
                                }
                                fputs("\n);\n", fp);//CREATE TABLE
                                
                                for (unsigned int j = 0; j < table->num_idxs; ++j) {
                                    MdbIndex *idx = (MdbIndex *)g_ptr_array_index (table->indices, j);
                                    if(idx->num_keys != 0) {
                                        std::string quoted_index_name = "[";
                                        quoted_index_name += (const char *)name.c_str();
                                        quoted_index_name += ".";
                                        quoted_index_name += idx->name;
                                        quoted_index_name += "]";
                                        fprintf(fp, "CREATE INDEX %s ON %s (\n",
                                                quoted_index_name.c_str(), quoted_table_name.c_str());
                                        for (unsigned int k = 0; k < idx->num_keys; ++k) {
                                            if(k) fputs(" , ", fp);
                                            MdbColumn *col= (MdbColumn *)g_ptr_array_index(table->columns, idx->key_col_num[k]-1);
                                            std::string quoted_field_name = "[";
                                            quoted_field_name += col->name;
                                            quoted_field_name += "]";
                                            fputs(quoted_field_name.c_str(), fp);
                                        }
                                        fputs("\n);\n", fp);//CREATE INDEX
                                    }
                                }
                                mdb_free_tabledef (table);
                            }
                        }
                    }
                    
                    fclose(fp);
                    ob_set_b(returnValue, L"success", true);
                }
            }else{
                ob_set_s(returnValue, "errorMessage", "failed: mdb_read_catalog()");
            }
            mdb_close(mdb);
        }else{
            ob_set_s(returnValue, "errorMessage", "failed: mdb_open()");
        }
    }

    PA_ReturnObject(params, returnValue);
}

static void print_properties(gpointer key, gpointer value, gpointer p) {
    
    ob_set_s((PA_ObjectRef)p, (const char *)key, (const char *)value);
}

static void mdb_tables(PA_PluginParameters params) {
    
//    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef returnValue;
    returnValue = PA_CreateObject();
    ob_set_b(returnValue, L"success", false);
    
    C_TEXT Param1;
    Param1.fromParamAtIndex(pParams, 1);
    CUTF8String path;
    Param1.copyUTF8String(&path);
    
    if(path.length()) {
        MdbHandle *mdb = mdb_open ((char *)path.c_str(), MDB_NOFLAGS);
        if(mdb) {
            if(mdb_read_catalog (mdb, MDB_ANY)) {
                PA_CollectionRef tables = PA_CreateCollection();
                for (unsigned int i = 0; i < mdb->num_catalog; ++i) {
                    MdbCatalogEntry *entry = (MdbCatalogEntry *)g_ptr_array_index (mdb->catalog, i);
                    
                    if(entry->object_type != MDB_TABLE) continue;
                                        
                    PA_ObjectRef table = PA_CreateObject();
                    ob_set_s(table, "name", (const char *)entry->object_name);
//                    ob_set_n(table, "id", entry->table_pg);
                    
                    if(mdb_is_system_table(entry)) {
                        ob_set_s(table, "type", "system");
                    }else if(mdb_is_user_table(entry)) {
                        ob_set_s(table, "type", "user");
                    }else{
                        ob_set_s(table, "type", "unknown");
                    }
                    
                    MdbTableDef *t = mdb_read_table (entry);
                    
                    mdb_read_columns(t);
                    mdb_rewind_table(t);
                    
                    PA_CollectionRef fields = PA_CreateCollection();
                    for (unsigned int j = 0; j < t->num_cols; ++j) {
                        MdbColumn *col = (MdbColumn *)g_ptr_array_index (t->columns, j);
                        PA_ObjectRef field = PA_CreateObject();
                        ob_set_s(field, "name", (const char *)col->name);
//                        ob_set_n(field, "id", col->row_col_num);
                        
                        if(col->is_long_auto) {
                            ob_set_b(field, L"autosequence", true);
                        }
                        if(col->is_uuid_auto) {
                            ob_set_b(field, L"autogenerate", true);
                        }
                        if (col->col_size != 0) {
                            ob_set_n(field,
                                     "length",
                                     col->col_size);
                        }
                        if (col->col_scale != 0) {
                            ob_set_n(field,
                                     "scale",
                                     col->col_scale);
                            ob_set_n(field,
                                     "precision",
                                     col->col_prec);
                        }
                        
                        switch (col->col_type) {
                            case MDB_BOOL:
                                ob_set_s(field,
                                         "type",
                                         "BOOL");
                                break;
                            case MDB_BYTE:
                                ob_set_s(field,
                                         "type",
                                         "BYTE");
                                break;
                            case MDB_INT:
                                ob_set_s(field,
                                         "type",
                                         "INT");
                                break;
                            case MDB_LONGINT:
                                ob_set_s(field,
                                         "type",
                                         "LONGINT");
                                break;
                            case MDB_MONEY:
                                ob_set_s(field,
                                         "type",
                                         "MONEY");
                                break;
                            case MDB_FLOAT:
                                ob_set_s(field,
                                         "type",
                                         "FLOAT");
                                break;
                            case MDB_DOUBLE:
                                ob_set_s(field,
                                         "type",
                                         "DOUBLE");
                                break;
                            case MDB_DATETIME:
                                ob_set_s(field,
                                         "type",
                                         "DATETIME");
                                break;
                            case MDB_BINARY:
                                ob_set_s(field,
                                         "type",
                                         "BINARY");
                                break;
                            case MDB_TEXT:
                                ob_set_s(field,
                                         "type",
                                         "TEXT");
                                break;
                            case MDB_OLE:
                                ob_set_s(field,
                                         "type",
                                         "OLE");
                                break;
                            case MDB_MEMO:
                                ob_set_s(field,
                                         "type",
                                         "MEMO");
                                break;
                            case MDB_REPID:
                                ob_set_s(field,
                                         "type",
                                         "REPID");
                                break;
                            case MDB_NUMERIC:
                                ob_set_s(field,
                                         "type",
                                         "NUMERIC");
                                break;
                            case MDB_COMPLEX:
                                ob_set_s(field,
                                         "type",
                                         "COMPLEX");
                                break;
                        }
                        
                        if(col->props) {
                            PA_ObjectRef properties = PA_CreateObject();
                            g_hash_table_foreach(col->props->hash, print_properties, properties);
                            ob_set_o(field, L"properties", properties);
                        }
                                                
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, field);
                        PA_SetCollectionElement(fields, PA_GetCollectionLength(fields), v);
                        PA_ClearVariable(&v);
                    }
                    
                    const char *description = mdb_table_get_prop(t, "Description");
                    if(description) {
                        ob_set_s(table, "description", description);
                    }
                    
                    mdb_free_tabledef(t);
                    
                    ob_set_c(table, L"fields", fields);

                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, table);
                    PA_SetCollectionElement(tables, PA_GetCollectionLength(tables), v);
                    PA_ClearVariable(&v);
                }
                ob_set_c(returnValue, L"tables", tables);
                ob_set_b(returnValue, L"success", true);
            }
            mdb_close(mdb);
        }else{
            ob_set_s(returnValue, "errorMessage", "failed: mdb_open()");
        }
    }

    PA_ReturnObject(params, returnValue);
}

static void mdb_sql(PA_PluginParameters params) {
        
//    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef returnValue;
    returnValue = PA_CreateObject();
    ob_set_b(returnValue, L"success", false);

    C_TEXT Param1;
    Param1.fromParamAtIndex(pParams, 1);
    CUTF8String path;
    Param1.copyUTF8String(&path);
    
    C_TEXT Param2;
    Param2.fromParamAtIndex(pParams, 2);
    CUTF8String sql;
    Param2.copyUTF8String(&sql);

    if(path.length()) {
        MdbSQL *mdbsql = mdb_sql_init();
        MdbHandle *mdb = mdb_sql_open(mdbsql, (char *)path.c_str());
        if(mdb) {
            mdb_sql_run_query(mdbsql, (const gchar *)sql.c_str());
            if (!mdb_sql_has_error(mdbsql)) {
                PA_CollectionRef rows = PA_CreateCollection();
                while(mdb_sql_fetch_row(mdbsql, mdbsql->cur_table)) {
                    PA_ObjectRef row = PA_CreateObject();
                    for (unsigned int j = 0; j < mdbsql->num_columns; ++j) {
                        MdbSQLColumn *sqlcol = (MdbSQLColumn *)g_ptr_array_index(mdbsql->columns, j);
                        ob_set_s(row,
                                 (const char *)sqlcol->name,
                                 (const char *)(g_ptr_array_index(mdbsql->bound_values, j)));
                    }
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, row);
                    PA_SetCollectionElement(rows, PA_GetCollectionLength(rows), v);
                    PA_ClearVariable(&v);
                }
                ob_set_c(returnValue, L"values", rows);
                ob_set_b(returnValue, L"success", true);
            }else{
                ob_set_s(returnValue, "errorMessage", mdb_sql_last_error(mdbsql));
                
            }
        }else{
            ob_set_s(returnValue, "errorMessage", "failed: mdb_open()");
        }
        mdb_sql_exit(mdbsql);
    }

    PA_ReturnObject(params, returnValue);
}

